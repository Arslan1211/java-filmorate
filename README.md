# Техническое задание

<details>  
<summary>Спринт 10</summary>

В этом спринте вы начнёте с малого, но очень важного: создадите каркас Spring Boot приложения **`Filmorate`** (от англ. _film_ — «фильм» и _rate_ — «оценивать»). В дальнейшем сервис будет обогащаться новым функционалом и с каждым спринтом становиться лучше благодаря вашим знаниям о Java.

### Предварительная настройка проекта

В этом модуле вы продолжите работать с финальными проектами по тому же алгоритму, что и раньше:

- Для каждого финального задания спринта создаётся отдельная ветка, в которой оно реализуется.
- После реализации и локальной проверки создаётся Pull Request на слияние изменений текущей ветки задания с основной веткой проекта.
- Перед тем, как будет осуществлено слияние веток — проводится автоматическая проверка в GitHub Actions.
- Если проверка прошла успешно, то ссылку на Pull Request можно отправлять на ревью. Если при проверке были найдены ошибки, то их нужно исправить и провести повторную проверку.

В репозитории уже подготовлено начальное описание сборки в ветке `main`. Создайте новую ветку `controllers-films-users`, в ней вы будете выполнять текущее задание. Не забывайте, что репозиторий при этом должен быть публичным.

Теперь можно шаг за шагом реализовать приложение.

### Модели данных

Создайте пакет `model`. Добавьте в него два класса: `Film` и `User`. Это классы — модели данных приложения.

У `model.Film` должны быть следующие свойства:

- целочисленный идентификатор — `id`;
- название — `name`;
- описание — `description`;
- дата релиза — `releaseDate`;
- продолжительность фильма — `duration`.

Свойства `model.User`:

- целочисленный идентификатор — `id`;
- электронная почта — `email`;
- логин пользователя — `login`;
- имя для отображения — `name`;
- дата рождения — `birthday`.


<details>  
<summary>Подсказка: про аннотацию @Data</summary>

Используйте аннотацию `@Data` библиотеки Lombok — с ней будет меньше работы по созданию сущностей.
</details>  

### Хранение данных

Сейчас данные можно хранить в памяти приложения — так же, как и в случае с менеджером задач. Для этого используйте контроллер.

В следующих спринтах вы узнаете, как правильно хранить данные в долговременном хранилище, чтобы они не зависели от перезапуска приложения.

### REST-контроллеры

Создайте два класса-контроллера. `FilmController` будет обслуживать фильмы, а `UserController` — пользователей. Убедитесь, что созданные контроллеры соответствуют правилам REST.

Добавьте в классы-контроллеры эндпоинты с подходящим типом запроса для каждого из случаев.

Для `FilmController`:

- добавление фильма;
- обновление фильма;
- получение всех фильмов.

Для `UserController`:

- создание пользователя;
- обновление пользователя;
- получение списка всех пользователей.

Эндпоинты для создания и обновления данных должны также вернуть созданную или изменённую сущность.


<details>  
<summary>Подсказка: про аннотацию @RequestBody</summary>

Используйте аннотацию `@RequestBody`, чтобы создать объект из тела запроса на добавление или обновление сущности.
</details>  

### Валидация

Проверьте данные, которые приходят в запросе на добавление нового фильма или пользователя. Эти данные должны соответствовать определённым критериям.

Для `Film`:

- название не может быть пустым;
- максимальная длина описания — 200 символов;
- дата релиза — не раньше 28 декабря 1895 года;
- продолжительность фильма должна быть положительным числом.

Для `User`:

- электронная почта не может быть пустой и должна содержать символ `@`;
- логин не может быть пустым и содержать пробелы;
- имя для отображения может быть пустым — в таком случае будет использован логин;
- дата рождения не может быть в будущем.


<details>  
<summary>Подсказка: как обработать ошибки</summary>

Для обработки ошибок валидации напишите новое исключение — например, `ValidationException`.
</details>  

### Логирование

Добавьте логирование для операций, которые изменяют сущности — добавляют и обновляют их. Также логируйте причины ошибок — например, если валидация не пройдена. Это считается хорошей практикой.

<details>  
<summary>Подсказка: про логирование сообщений</summary>

Воспользуйтесь библиотекой `slf4j` для логирования и объявляйте логер для каждого класса — так будет сразу видно, где в коде выводится та или иная строка.

```Java
private final static Logger log = LoggerFactory.getLogger(Example.class); 
```

Вы также можете применить аннотацию `@Slf4j` библиотеки Lombok, чтобы не создавать логер вручную.
</details>  

### Тестирование

Добавьте unit-тесты для валидации моделей. Убедитесь, что она работает на граничных условиях.

<details>  
<summary>Подсказка: на что обратить внимание при тестировании</summary>

Проверьте, что валидация не пропускает пустые или неверно заполненные поля. Посмотрите, как контроллер реагирует на пустой запрос.
</details>  

### Проверьте себя

Так как у вашего API пока нет интерфейса, вы будете взаимодействовать с ним через веб-клиент. Мы подготовили набор тестовых данных — Postman-коллекцию. С её помощью вы сможете протестировать ваш API: [_postman.json_](https://github.com/yandex-praktikum/java-filmorate/blob/controllers-films-users/postman/sprint.json).

### Дополнительное задание*

А здесь — необязательное задание для самых смелых! Валидация, которую нужно реализовать в основном задании, — базовая. Она не покрывает всех возможных ошибок. Например, всё ещё можно создать пользователя с такой электронной почтой: `это-неправильный?эмейл@`.

В Java есть инструменты для проверки корректности различных данных. С помощью аннотаций можно задать ограничения, которые будут проверяться автоматически. Для этого добавьте в описание сборки проекта следующую зависимость.


```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
</dependency> 
```

Теперь вы можете применить аннотацию `@NotNull` к полю класса-модели для проверки на `null`, `@NotBlank` — для проверки на пустую строку, `@Email` — для проверки на соответствие формату электронного адреса. Полный список доступных аннотаций можно найти в [документации](https://docs.jboss.org/hibernate/beanvalidation/spec/2.0/api/javax/validation/constraints/package-summary.html).

Чтобы Spring не только преобразовал тело запроса в соответствующий класс, но и проверил корректность переданных данных, вместе с аннотацией `@RequestBody` нужно использовать аннотацию `@Valid`.

```Java
public createUser(@Valid @RequestBody User user) 
```
</details> 

<details>  
<summary>Спринт 11</summary>

Настало время улучшить `Filmorate`. Чтобы составлять рейтинг фильмов, нужны отзывы пользователей. А для улучшения рекомендаций по просмотру хорошо бы объединить пользователей в комьюнити.

По итогам прошлого спринта у вас получилась заготовка приложения. Программа может принимать, обновлять и возвращать пользователей и фильмы. В этот раз улучшим API приложения до соответствия REST, а также изменим архитектуру приложения с помощью внедрения зависимостей.

### Наводим порядок в репозитории

Для начала убедитесь в том, что ваши изменения за предыдущий спринт добавлены в ветку `main`. Создайте новую ветку, которая будет называться `add-friends-likes`. Название ветки важно сохранить, потому что оно влияет на запуск тестов в GitHub.


<details>  
<summary>Подсказка: про работу в Git</summary>

Для слияния веток используйте команду `merge`.
</details>

### Архитектура

Начнём с переработки архитектуры. Сейчас вся логика приложения спрятана в контроллерах — изменим это. Вынесите хранение данных о фильмах и пользователях в отдельные классы. Назовём их **хранилищами** (англ. _storage_) — так будет сразу понятно, что они делают.

- Создайте интерфейсы `FilmStorage` и `UserStorage`, в которых будут определены методы добавления, удаления и модификации объектов.
- Создайте классы `InMemoryFilmStorage` и `InMemoryUserStorage`, имплементирующие новые интерфейсы, и перенесите туда всю логику хранения, обновления и поиска объектов.
- Добавьте к `InMemoryFilmStorage` и `InMemoryUserStorage` аннотацию `@Component`, чтобы впоследствии пользоваться внедрением зависимостей и передавать хранилища сервисам.

<details>  
<summary>Подсказка: про структуру проекта</summary>

Чтобы объединить хранилища, создайте новый пакет `storage`. В нём будут только классы и интерфейсы, имеющие отношение к хранению данных. Например, `ru.yandex.filmorate.storage.film.FilmStorage`.
</details>

### Новая логика

Пока у приложения нет никакой бизнес-логики, кроме валидации сущностей. Обеспечим возможность пользователям добавлять друг друга в друзья и ставить фильмам лайки.

- Создайте `UserService`, который будет отвечать за такие операции с пользователями, как добавление в друзья, удаление из друзей, вывод списка общих друзей. Пока пользователям не надо одобрять заявки в друзья — добавляем сразу. То есть если Лена стала другом Саши, то это значит, что Саша теперь друг Лены.
- Создайте `FilmService`, который будет отвечать за операции с фильмами — добавление и удаление лайка, вывод 1010 наиболее популярных фильмов по количеству лайков. Пока пусть каждый пользователь может поставить лайк фильму только один раз.
- Добавьте к ним аннотацию `@Service` — тогда к ним можно будет получить доступ из контроллера.

<details>  
<summary>Подсказка: ещё про структуру</summary>

По аналогии с хранилищами объедините бизнес-логику в пакет `service`.
</details>


<details>  
<summary>Подсказка: про список друзей и лайки</summary>

Есть много способов хранить информацию о том, что два пользователя являются друзьями. Например, можно создать свойство `friends` в классе пользователя, которое будет содержать список его друзей. Вы можете использовать такое решение или придумать своё.

Чтобы обеспечить уникальность значения (нельзя добавить одного человека в друзья дважды), проще всего использовать для хранения `Set<Long>` c id друзей. Таким же образом можно обеспечить условие «один пользователь — один лайк» для оценки фильмов.
</details>


### Зависимости

Переделайте код в контроллерах, сервисах и хранилищах под использование внедрения зависимостей.

- Используйте аннотации `@Service`, `@Component`, `@Autowired`. Внедряйте зависимости через конструкторы классов.
- Классы-сервисы должны иметь доступ к классам-хранилищам. Убедитесь, что сервисы зависят от интерфейсов классов-хранилищ, а не их реализаций. Таким образом в будущем будет проще добавлять и использовать новые реализации с другим типом хранения данных.
- Сервисы должны быть внедрены в соответствующие контроллеры.

<details>  
<summary>Подсказка: @Service vs @Component</summary>

`@Component` — аннотация, которая определяет класс как управляемый Spring. Такой класс будет добавлен в контекст приложения при сканировании. `@Service` не отличается по поведению, но обозначает более узкий спектр классов — такие, которые содержат в себе бизнес-логику и, как правило, не хранят состояние.
</details>

### Полный REST

Дальше стоит заняться контроллерами и довести API до соответствия REST.

- С помощью аннотации `@PathVariable` добавьте возможность получать каждый фильм и данные о пользователях по их уникальному идентификатору: `GET .../users/{id}`.
- Добавьте методы, позволяющие пользователям добавлять друг друга в друзья, получать список общих друзей и лайкать фильмы. Проверьте, что все они работают корректно.
    - `PUT /users/{id}/friends/{friendId}` — добавление в друзья.
    - `DELETE /users/{id}/friends/{friendId}` — удаление из друзей.
    - `GET /users/{id}/friends` — возвращаем список пользователей, являющихся его друзьями.
    - `GET /users/{id}/friends/common/{otherId}` — список друзей, общих с другим пользователем.
    - `PUT /films/{id}/like/{userId}` — пользователь ставит лайк фильму.
    - `DELETE /films/{id}/like/{userId}` — пользователь удаляет лайк.
    - `GET /films/popular?count={count}` — возвращает список из первых `count` фильмов по количеству лайков. Если значение параметра `count` не задано, верните первые 1010.
- Убедитесь, что ваше приложение возвращает корректные HTTP-коды:
    - 400400 — если ошибка валидации: `ValidationException`;
    - 404404 — для всех ситуаций, если искомый объект не найден;
    - 500500 — если возникло исключение.

<details>  
<summary>Подсказка</summary>

Настройте`ExceptionHandler` для централизованной обработки ошибок.
</details>

### Дополнительное логирование

Разработка любого приложения не застрахована от ошибок. Синтаксические ошибки поможет обнаружить компилятор, а вот логические обнаружить намного сложнее.

В процессе проектирования и написания кода приложения учтите места, в которых будет разумно добавить отладочные сообщения. Это поможет разобраться с возможными ошибками и другими проявлениями некорректной реализации.

Также подключите к проекту дополнительный стартер:

```XML
<dependency>
    <groupId>org.zalando</groupId>
    <artifactId>logbook-spring-boot-starter</artifactId>
    <version>3.7.2</version>
</dependency>
```

Этот стартер интегрирует в Spring Framework [библиотеку Logbook](https://github.com/zalando/logbook). Она будет выводить в лог информацию об HTTP-запросах и ответах.

Кроме подключения внешней зависимости, нужно настроить уровень логера, который ответственен за вывод деталей об HTTP-сообщениях. Для этого добавьте в конфигурационный файл следующее свойство:

```XML
logging.level.org.zalando.logbook: TRACE
```

Теперь библиотека будет выводить в лог информацию о деталях запроса и ответа в формате JSON.

<details>  
<summary>Подробнее о том, как будет выглядеть вывод с Logbook</summary>
Пример вывода:

```LOG
2024-04-05T12:38:04.538+03:00 TRACE 6562 --- [nio-8080-exec-2] org.zalando.logbook.Logbook              : {"origin":"remote","type":"request","correlation":"a20d8031dc76768d","protocol":"HTTP/1.1","remote":"0:0:0:0:0:0:0:1","method":"POST","uri":"http://localhost:8080/users","host":"localhost","path":"/users","scheme":"http","port":"8080","headers":{"accept":["*/*"],"accept-encoding":["gzip, deflate, br"],"cache-control":["no-cache"],"connection":["keep-alive"],"content-length":["143"],"content-type":["application/json"],"host":["localhost:8080"],"postman-token":["ae7d451b-ad84-4862-92f1-196c6908cdf0"],"user-agent":["PostmanRuntime/7.37.0"]},"body":{"email":"vasilii.pupkin@practicum.ru","name":"Василий Пупкин","login":"pumpkin","birthday":"1986-08-20"}}
2024-04-05T12:38:04.646+03:00 TRACE 6562 --- [nio-8080-exec-2] org.zalando.logbook.Logbook              : {"origin":"local","type":"response","correlation":"a20d8031dc76768d","duration":137,"protocol":"HTTP/1.1","status":200,"headers":{"Connection":["keep-alive"],"Content-Type":["application/json"],"Date":["Fri, 05 Apr 2024 09:38:04 GMT"],"Keep-Alive":["timeout=60"],"Transfer-Encoding":["chunked"]},"body":{"id":1,"email":"vasilii.pupkin@practicum.ru","login":"pumpkin","name":"Василий Пупкин","birthday":"1986-08-20"}}
```

Основные поля:

- в `type` находится тип лога — `request` для запроса или `response` для ответа;
- в `headers` — заголовки запроса/ответа;
- в `body` — тело запроса/ответа.

Входящий запрос:

- в `method` — HTTP-метод запроса;
- в `uri` — URI запроса, по которому был вызван метод;
- в `path` — путь запроса.

Ответ:

- в `duration` — время продолжительности ответа (в миллисекундах);
- в `status` — HTTP-статус ответа.
</details>

### Тестирование

Убедитесь, что приложение работает, — протестируйте его с помощью Postman: [postman.json](https://github.com/yandex-praktikum/java-filmorate/blob/add-friends-likes/postman/sprint.json).
</details>

<details>  
<summary>Спринт 12</summary>

<details>  
<summary>Промежуточное задание</summary>

# Техническое задание

Спроектировать базу данных для проекта, основываясь на уже существующей функциональности.

<details>  
<summary>Описание таблиц базы данных фильмотеки</summary>


## Таблица `films` (Фильмы)

- `film_id` - уникальный идентификатор фильма (автоинкремент)

- `name` - название фильма (обязательное поле)

- `description` - описание фильма (максимум 200 символов)

- `releaseDate` - дата выхода фильма

- `duration` - длительность фильма в минутах

- `rating` - рейтинг фильма (внешний ключ на таблицу ratings)


## Таблица `users` (Пользователи)

- `user_id` - уникальный идентификатор пользователя (автоинкремент)

- `email` - электронная почта пользователя (уникальное, обязательное поле)

- `login` - логин пользователя (уникальное, обязательное поле)

- `name` - имя пользователя (обязательное поле)

- `birthday` - дата рождения пользователя


## Таблица `likes` (Лайки)

- `like_id` - уникальный идентификатор лайка (автоинкремент)

- `user_id` - идентификатор пользователя (внешний ключ на users)

- `film_id` - идентификатор фильма (внешний ключ на films)


## Таблица `friendships` (Дружба)

- `id` - уникальный идентификатор дружбы (автоинкремент)

- `user_id` - идентификатор пользователя (внешний ключ на users)

- `friend_id` - идентификатор друга (внешний ключ на users)


## Таблица `genres` (Жанры)

- `genre_id` - уникальный идентификатор жанра (автоинкремент)

- `name` - название жанра (уникальное, обязательное поле)


## Таблица `film_genres` (Жанры фильмов)

- `id` - уникальный идентификатор записи (автоинкремент)

- `genre_id` - идентификатор жанра (внешний ключ на genres)

- `film_id` - идентификатор фильма (внешний ключ на films)


## Таблица `ratings` (Рейтинги)

- `id` - уникальный идентификатор рейтинга (автоинкремент)

- `name` - название рейтинга (уникальное, обязательное поле)
</details>  


<details>  
<summary>Структура БД</summary>


  ```sql
  
  Table films {
  
    film_id serial [primary key]
  
    name varchar [not null]
  
    description char(200)
  
    releaseDate date
  
    duration integer
  
    rating integer
  
  }
  
    
  
  Table users {
  
    user_id serial [primary key]
  
    email varchar [not null, unique]
  
    login varchar [not null, unique]
  
    name varchar [not null]
  
    birthday date
  
  }
  
    
  
  Table likes {
  
    like_id serial [primary key]
  
    user_id integer [not null]
  
    film_id integer [not null]
  
  }
  
    
  
  Table friendships {
  
    id serial [primary key]
  
    user_id integer [not null]
  
    friend_id integer [not null]
  
  }
  
    
  
  Table genres {
  
    genre_id serial [primary key]
  
    name varchar [not null, unique]
  
  }
  
    
  
  Table film_genres {
  
    id serial [primary key]
  
    genre_id integer [not null]
  
    film_id integer [not null]
  
  }
  
    
  
  Table ratings {
  
    id serial [primary key]
  
    name varchar [not null, unique]
  
  }
  
    
  
  Ref: films.rating > ratings.id
  
    
  
  Ref: likes.user_id > users.user_id
  
  Ref: likes.film_id > films.film_id
  
    
  
  Ref: friendships.user_id > users.user_id
  
  Ref: friendships.friend_id > users.user_id
  
    
  
  Ref: film_genres.genre_id > genres.genre_id
  
  Ref: film_genres.film_id > films.film_id
  ```

</details>  

<details>  
<summary>Создание таблиц</summary>

```sql

CREATE TABLE ratings (
    id SERIAL PRIMARY KEY,
    name VARCHAR NOT NULL UNIQUE
);

CREATE TABLE users (
    user_id SERIAL PRIMARY KEY,
    email VARCHAR NOT NULL UNIQUE,
    login VARCHAR NOT NULL UNIQUE,
    name VARCHAR NOT NULL,
    birthday DATE
);

CREATE TABLE films (
    film_id SERIAL PRIMARY KEY,
    name VARCHAR NOT NULL,
    description CHAR(200),
    releaseDate DATE,
    duration INTEGER,
    rating INTEGER,
    CONSTRAINT fk_rating FOREIGN KEY (rating) REFERENCES ratings(id) ON DELETE SET NULL
);

CREATE TABLE genres (
    genre_id SERIAL PRIMARY KEY,
    name VARCHAR NOT NULL UNIQUE
);

CREATE TABLE likes (
    like_id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL,
    film_id INTEGER NOT NULL,
    CONSTRAINT fk_user FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE,
    CONSTRAINT fk_film FOREIGN KEY (film_id) REFERENCES films(film_id) ON DELETE CASCADE
);

CREATE TABLE friendships (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL,
    friend_id INTEGER NOT NULL,
    CONSTRAINT fk_user1 FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE,
    CONSTRAINT fk_user2 FOREIGN KEY (friend_id) REFERENCES users(user_id) ON DELETE CASCADE
);

CREATE TABLE film_genres (
    id SERIAL PRIMARY KEY,
    genre_id INTEGER NOT NULL,
    film_id INTEGER NOT NULL,
    CONSTRAINT fk_genre FOREIGN KEY (genre_id) REFERENCES genres(genre_id) ON DELETE CASCADE,
    CONSTRAINT fk_film_genre FOREIGN KEY (film_id) REFERENCES films(film_id) ON DELETE CASCADE
);
```

</details>  


</details>

</details>  